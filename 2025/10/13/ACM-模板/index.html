<!DOCTYPE html>
<html 
	lang="en">
	<head>
		<meta name="referrer" content="no-referrer" />
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> ACM 模板 -  Zephyr&#39;s Blog</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="https://s2.loli.net/2025/10/09/HOlMi56LxpNY4Vd.jpg"
			type="image/png"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

	<body>
		
		<meta name="referrer" content="no-referrer" />
		<div
			class="kira-background"
			style="background-image: url('https://s2.loli.net/2025/10/09/scpovNECqUnVAx7.jpg')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="Zephyr&#39;s Blog">
        <img
			src="https://s2.loli.net/2025/10/09/HOlMi56LxpNY4Vd.jpg"
			alt="青筱听风"
		/>
    </a>
</div>
	
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a target="_blank" rel="noopener" href="https://s2.loli.net/2025/10/09/HOlMi56LxpNY4Vd.jpg" title="青筱听风">
			<img
				src="https://s2.loli.net/2025/10/09/HOlMi56LxpNY4Vd.jpg"
				alt="青筱听风"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>17</div>
		<div><span>标签</span>5</div>
		<div><span>分类</span>3</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive.html"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about.html"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2631231131&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://space.bilibili.com/3546915450915197"
				target="_blank"
				mdui-tooltip="{content: '哔哩哔哩'}"
				style="color: rgb(231, 106, 141); background-color: rgba(231, 106, 141, .15);"
			>
				<i
					class="kirafont
					
						icon-bilibili
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/Lorcas-Zephyr/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://gitee.com/lorcas"
				target="_blank"
				mdui-tooltip="{content: 'Gitee'}"
				style="color: rgb(165, 15, 15); background-color: rgba(165, 15, 15, .15);"
			>
				<i
					class="kirafont
					
						icon-gitee
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/教程/">
              教程
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/模板/">
              模板
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/题解/">
              题解
            </a>
            <span class="category-list-count">15</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/ACM/" style="font-size: 10px;">ACM</a> <a href="/tags/Atcoder/" style="font-size: 10px;">Atcoder</a> <a href="/tags/Codeforces/" style="font-size: 15px;">Codeforces</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/%E6%B4%9B%E8%B0%B7/" style="font-size: 20px;">洛谷</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			Archive
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">2</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2025
		<a href="/">青筱听风</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div
			class="kira-post-cover"
			style="padding-bottom: '56.25%'"
		>
			<img
				data-src="https://s2.loli.net/2025/10/09/scpovNECqUnVAx7.jpg"
				data-sizes="auto"
				alt="ACM 模板"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>ACM 模板</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2025年10月13日</a>
			<a><i class="kirafont icon-edit-fill"></i>8k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 40 分钟</a>
		</div>
		<!-- omit in toc --><html><head></head><body><h1><span id="acm-icpc-%E6%A8%A1%E6%9D%BF">ACM-ICPC 模板</span></h1><!-- omit in toc -->
<h2><span id="%E7%9B%AE%E5%BD%95">目录</span></h2><ul>
<li><a href="#1快速幂">1.快速幂</a></li>
<li><a href="#2差分数组">2.差分数组</a></li>
<li><a href="#301背包">3.01背包</a></li>
<li><a href="#4完全背包">4.完全背包</a></li>
<li><a href="#5多重背包1维数组">5.多重背包（1维数组）</a></li>
<li><a href="#6区间dp石子合并环形">6.区间dp（石子合并（环形））</a></li>
<li><a href="#7线段树">7.线段树</a></li>
<li><a href="#8dijkstra不可处理负权边负环">8.dijkstra（不可处理负权边、负环）</a></li>
<li><a href="#9spfa可处理负权边负环">9.SPFA（可处理负权边、负环）</a></li>
<li><a href="#10bellman-ford">10.Bellman-Ford</a></li>
<li><a href="#11floyd">11.Floyd</a></li>
<li><a href="#12网络流最大流dicnic">12.网络流最大流（Dicnic）</a></li>
<li><a href="#13最小费用最大流spfa">13.最小费用最大流（SPFA）</a></li>
<li><a href="#14单调队列">14.单调队列</a></li>
<li><a href="#15树的直径">15.树的直径</a></li>
<li><a href="#16stl">16.STL</a></li>
</ul>
<h3><span id="1%E5%BF%AB%E9%80%9F%E5%B9%82">1.快速幂</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fastPowMod</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power, <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    base = base % mod; <span class="hljs-comment">// 先取模防止溢出</span><br>    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) {<br>            result = (result * base) % mod;<br>        }<br>        base = (base * base) % mod;<br>        power &gt;&gt;= <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="2%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84">2.差分数组</span></h3><ul>
<li>一维</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>; <span class="hljs-comment">// 根据题目要求调整大小</span><br><span class="hljs-type">int</span> a[N];    <span class="hljs-comment">// 原数组</span><br><span class="hljs-type">int</span> diff[N]; <span class="hljs-comment">// 差分数组</span><br><br><span class="hljs-comment">// 初始化差分数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_diff</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>    diff[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {<br>        diff[i] = a[i] - a[i<span class="hljs-number">-1</span>];<br>    }<br>}<br><span class="hljs-comment">// 给区间 [l, r] 增加 val</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>{<br>    diff[l] += val;<br>    <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; N) { <span class="hljs-comment">// 防止越界</span><br>        diff[r<span class="hljs-number">+1</span>] -= val;<br>    }<br>}<br><span class="hljs-comment">// 计算操作后的原数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>    a[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {<br>        a[i] = a[i<span class="hljs-number">-1</span>] + diff[i];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>二维</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1010</span>, N = <span class="hljs-number">1010</span>; <span class="hljs-comment">// 根据题目要求调整大小</span><br><span class="hljs-type">int</span> a[M][N];    <span class="hljs-comment">// 原矩阵</span><br><span class="hljs-type">int</span> diff[M][N]; <span class="hljs-comment">// 差分矩阵</span><br><br><span class="hljs-comment">// 初始化差分矩阵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_diff_2d</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>            diff[i][j] = a[i][j] - a[i<span class="hljs-number">-1</span>][j] - a[i][j<span class="hljs-number">-1</span>] + a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        }<br>    }<br>}<br><span class="hljs-comment">// 给子矩阵 (x1,y1)到(x2,y2) 增加 val</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_2d</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> val)</span> </span>{<br>    diff[x1][y1] += val;<br>    diff[x2<span class="hljs-number">+1</span>][y1] -= val;<br>    diff[x1][y2<span class="hljs-number">+1</span>] -= val;<br>    diff[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>] += val;<br>}<br><span class="hljs-comment">// 计算操作后的原矩阵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore_2d</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>            a[i][j] = a[i<span class="hljs-number">-1</span>][j] + a[i][j<span class="hljs-number">-1</span>] - a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + diff[i][j];<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="301%E8%83%8C%E5%8C%85">3.01背包</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1000</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,m,f[MAXN][MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    <span class="hljs-type">int</span> t,v;<br>}a[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        cin&gt;&gt;a[i].t&gt;&gt;a[i].v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        {<br>            f[i][j]=f[i<span class="hljs-number">-1</span>][j];  <span class="hljs-comment">// 默认不选当前物品</span><br>            <span class="hljs-comment">// 如果当前容量可以放下当前物品，考虑选择它的情况</span><br>            <span class="hljs-keyword">if</span>(j&gt;=a[i].t) f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j-a[i].t]+a[i].v,f[i][j]);<br>        }<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>        ans=<span class="hljs-built_in">max</span>(ans,f[n][i]);<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="4%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">4.完全背包</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">20010</span>;<br><span class="hljs-type">int</span> m,n,f[MAXN],g[MAXN],a[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));<span class="hljs-comment">// 最少硬币数初始化为无穷大（表示不可达）</span><br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">-0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<span class="hljs-comment">// 最多硬币数初始化为负无穷大（表示不可达）</span><br>    f[<span class="hljs-number">0</span>]=g[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(i&gt;=a[j]) <br>            {<br>                f[i]=<span class="hljs-built_in">min</span>(f[i-a[j]]<span class="hljs-number">+1</span>,f[i]);<span class="hljs-comment">// 更新最少硬币数</span><br>                g[i]=<span class="hljs-built_in">max</span>(g[i-a[j]]<span class="hljs-number">+1</span>,g[i]);<span class="hljs-comment">// 更新最多硬币数</span><br>            }<br>    cout&lt;&lt;f[m]&lt;&lt;endl&lt;&lt;g[m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="5%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%851%E7%BB%B4%E6%95%B0%E7%BB%84">5.多重背包（1维数组）</span></h3><ul>
<li>转换成01背包<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,m,v,w,mm,f[<span class="hljs-number">40010</span>],cnt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    <span class="hljs-type">int</span> v,w;<br>}a[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    {<br>        cin&gt;&gt;v&gt;&gt;w&gt;&gt;mm;<br>        <span class="hljs-comment">// 二进制拆分：将数量mm拆分为1, 2, 4, ..., 剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=mm;k*=<span class="hljs-number">2</span>)<br>        {<br>            a[++cnt].v=v*k;<span class="hljs-comment">// 拆分后的物品价值 = 原价值 * 拆分数量</span><br>            a[cnt].w=w*k;<span class="hljs-comment">// 拆分后的物品重量 = 原重量 * 拆分数量</span><br>            mm-=k; <span class="hljs-comment">// 减去已拆分的数量</span><br>        }<br>        <span class="hljs-comment">// 处理剩余部分（无法用2的幂次表示的部分）</span><br>        a[++cnt].v=v*mm;<br>        a[cnt].w=w*mm;<br>    }<br>    <span class="hljs-comment">// 动态规划：01背包求解</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)<br>    {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)<br>        {<br>            <span class="hljs-keyword">if</span>(j&gt;=a[i].w) f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-a[i].w]+a[i].v);<br>        }<br>    }<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>        ans=<span class="hljs-built_in">max</span>(ans,f[i]);<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3><span id="6%E5%8C%BA%E9%97%B4dp%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%E7%8E%AF%E5%BD%A2">6.区间dp（石子合并（环形））</span></h3><ul>
<li>非环形，即去掉2倍部分</li>
<li>环形，第一重循环的i，j差无需到2*n</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> n,f[MAXN][MAXN],a[MAXN],sum[MAXN],g[MAXN][MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(f));<span class="hljs-comment">// 初始化f数组为极大值（因为要求最小值）</span><br>    <span class="hljs-comment">// 输入石子重量并进行环形扩展</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    {<br>        cin&gt;&gt;a[i];<br>        a[i+n]=a[i]; <span class="hljs-comment">// 环形扩展：将数组复制一份接在后面</span><br>        f[i][i]=f[i+n][i+n]=<span class="hljs-number">0</span>;<span class="hljs-comment">// 单堆石子不需要合并，代价为0</span><br>    }<br>      <span class="hljs-comment">// 计算前缀和数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)<br>        sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;n;l++) <span class="hljs-comment">// l表示区间长度，从1到n-1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>-l;i++)<span class="hljs-comment">// i表示区间起点</span><br>        {<br>            <span class="hljs-type">int</span> j=i+l; <span class="hljs-comment">// j表示区间终点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++) <span class="hljs-comment">// k表示分割点</span><br>            {<br>                f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i][k]+f[k<span class="hljs-number">+1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">// 更新最小合并代价</span><br>                g[i][j]=<span class="hljs-built_in">max</span>(g[i][j],g[i][k]+g[k<span class="hljs-number">+1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">// 更新最大合并代价</span><br>            }<br>        }<br>    <span class="hljs-type">int</span> ans1=<span class="hljs-number">0x3f3f3f3f</span>,ans2=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历所有可能的起点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    {<br>        ans1=<span class="hljs-built_in">min</span>(ans1,f[i][i+n<span class="hljs-number">-1</span>]);<br>        ans2=<span class="hljs-built_in">max</span>(ans2,g[i][i+n<span class="hljs-number">-1</span>]);<br>    }<br>    cout&lt;&lt;ans1&lt;&lt;endl&lt;&lt;ans2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="7%E7%BA%BF%E6%AE%B5%E6%A0%91">7.线段树</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxn 100010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[Maxn],n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> l,r,sum,lz;<br>}tree[Maxn&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-comment">//建树 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i,<span class="hljs-type">long</span> <span class="hljs-type">long</span> l,<span class="hljs-type">long</span> <span class="hljs-type">long</span> r)</span></span><br><span class="hljs-function"></span>{<br>    tree[i].l=l;<br>    tree[i].r=r;<br>    <span class="hljs-keyword">if</span>(l==r)<br>    {<br>        tree[i].sum=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    <span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,r);<br>    tree[i].sum=tree[i&lt;&lt;<span class="hljs-number">1</span>].sum+tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>}<br><span class="hljs-comment">//单点加</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i,<span class="hljs-type">long</span> <span class="hljs-type">long</span> dis,<span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br>    {<br>        tree[i].sum+=k;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">if</span>(dis&lt;=tree[i&lt;&lt;<span class="hljs-number">1</span>].r) <span class="hljs-built_in">update</span>(i&lt;&lt;<span class="hljs-number">1</span>,dis,k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,dis,k);<br>    tree[i].sum=tree[i&lt;&lt;<span class="hljs-number">1</span>].sum+tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>}<br><span class="hljs-comment">//更新lz</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(tree[i].lz!=<span class="hljs-number">0</span>) <span class="hljs-comment">// 如果当前节点有未处理的延迟标记</span><br>    {<br>        tree[i&lt;&lt;<span class="hljs-number">1</span>].lz+=tree[i].lz;<br><span class="hljs-comment">// 1. 将延迟标记传递给左子节点</span><br>        tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lz+=tree[i].lz;<br><span class="hljs-comment">// 2. 将延迟标记传递给右子节点</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid=(tree[i].l+tree[i].r)/<span class="hljs-number">2</span>;<br>        tree[i&lt;&lt;<span class="hljs-number">1</span>].sum+=tree[i].lz*(mid-tree[i&lt;&lt;<span class="hljs-number">1</span>].l<span class="hljs-number">+1</span>);<br>    <span class="hljs-comment">// 3. 更新左子节点的区间和（加上延迟标记值×左子区间长度）</span><br>        tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum+=tree[i].lz*(tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-mid);<br>    <span class="hljs-comment">// 4. 更新右子节点的区间和（加上延迟标记值×右子区间长度）</span><br>        tree[i].lz=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 5. 清除当前节点的延迟标记（已传递给子节点）</span><br>    }<br>}<br><span class="hljs-comment">//区间加</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i,<span class="hljs-type">long</span> <span class="hljs-type">long</span> l,<span class="hljs-type">long</span> <span class="hljs-type">long</span> r,<span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<br>    {<br>        tree[i].sum+=k*(tree[i].r-tree[i].l<span class="hljs-number">+1</span>);<br>        tree[i].lz+=k;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-built_in">pushdown</span>(i);<span class="hljs-comment">// 需要访问子节点，先下传当前节点的延迟标记</span><br>    <span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) <span class="hljs-built_in">add</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br>    <span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) <span class="hljs-built_in">add</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>    tree[i].sum=tree[i&lt;&lt;<span class="hljs-number">1</span>].sum+tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>}<br><span class="hljs-comment">//区间查询 </span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i,<span class="hljs-type">long</span> <span class="hljs-type">long</span> l,<span class="hljs-type">long</span> <span class="hljs-type">long</span> r)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(tree[i].l&gt;=l <span class="hljs-keyword">and</span> tree[i].r&lt;=r)<br>        <span class="hljs-keyword">return</span> tree[i].sum;<br>    <span class="hljs-keyword">if</span>(tree[i].r&lt;l <span class="hljs-keyword">or</span> tree[i].l&gt;r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pushdown</span>(i);<span class="hljs-comment">// 需要访问子节点，先下传当前节点的延迟标记</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>].r&gt;=l) sum+=<span class="hljs-built_in">query</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">if</span>(tree[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l&lt;=r) sum+=<span class="hljs-built_in">query</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">return</span> sum;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        cin&gt;&gt;a[i];<br>        <br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    {<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> op;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        {<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> l,r,k;<br>            cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;<br>            <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,l,r,k);<br>        }<br>        <span class="hljs-keyword">else</span>{<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> l,r;<br>            cin&gt;&gt;l&gt;&gt;r;<br>            cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,l,r)&lt;&lt;endl;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="8dijkstra%E4%B8%8D%E5%8F%AF%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E8%BE%B9%E8%B4%9F%E7%8E%AF">8.dijkstra（不可处理负权边、负环）</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> head[MAXN];<br><span class="hljs-type">int</span> n,mm,s;<br><span class="hljs-type">bool</span> b[MAXN];<br><span class="hljs-type">int</span> d[MAXN],id;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    <span class="hljs-type">int</span> s,v,lk;<br>}m[MAXN];<br><span class="hljs-comment">//邻接表加边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    id++;<br>    m[id].v=v;<br>    m[id].s=x;<br>    m[id].lk=head[u];<br>    head[u]=id;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    d[u]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 定义小根堆（优先队列）：存储(距离, 节点)对，按距离从小到大排序</span><br><span class="hljs-comment">// 作用：高效获取当前距离源点最近的未处理节点（时间复杂度O(logn) per operation）</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; &gt; q;<br>    q.<span class="hljs-built_in">push</span>({<span class="hljs-number">0</span>,u});<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    {<br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; t=q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">// 取出队首元素（当前距离最小的节点信息）</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> v=t.second;<br>        <span class="hljs-type">int</span> s=t.first;<br>        <span class="hljs-keyword">if</span>(b[v]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 如果节点v已被处理过（最短距离已确定），跳过（避免重复处理）</span><br>        b[v]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历节点v的所有邻接边（通过邻接表）</span><br>    <span class="hljs-comment">// 循环条件：i从v的邻接表表头开始，直到i=0（表示没有更多邻接边）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[v];i!=<span class="hljs-number">0</span>;i=m[i].lk)<br>        {<br>            <span class="hljs-type">int</span> j=m[i].v;<br>            <span class="hljs-comment">//cout&lt;&lt;d[j]&lt;&lt;' '&lt;&lt;s&lt;&lt;' '&lt;&lt;m[i].s&lt;&lt;endl;// 松弛操作（Relaxation，Dijkstra算法的核心步骤）</span><br>        <span class="hljs-comment">// 条件：通过v→j的路径，源点到j的距离比原来的d[j]更短</span><br>            <span class="hljs-keyword">if</span>(d[j]&gt;s+m[i].s)<br>            {<br>                d[j]=m[i].s+s;<br>                q.<span class="hljs-built_in">push</span>({d[j],j});<br>            }<br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin&gt;&gt;n&gt;&gt;mm&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=mm;i++)<br>    {<br>        <span class="hljs-type">int</span> u,v,x;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;x;<br>        <span class="hljs-built_in">add</span>(u,v,x);<br>    }<br>    <span class="hljs-built_in">dij</span>(s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        cout&lt;&lt;d[i]&lt;&lt;<span class="hljs-string">' '</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="9spfa%E5%8F%AF%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E8%BE%B9%E8%B4%9F%E7%8E%AF">9.SPFA（可处理负权边、负环）</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,mm,s,d[MAXN],h[MAXN],cnt[MAXN];<br><span class="hljs-type">bool</span> b[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    <span class="hljs-type">int</span> u,v,w,lk; <span class="hljs-comment">// u: 边的起点；v: 边的终点；w: 边的权值；lk: 下一条边的索引（邻接表链式存储）</span><br>}m[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin&gt;&gt;n&gt;&gt;mm&gt;&gt;s;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<span class="hljs-comment">// 初始化距离数组为无穷大（0x3f是一个远大于图中可能路径长度的数）</span><br>    d[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">// 源点到自身的距离为0</span><br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<span class="hljs-comment">// 初始化邻接表表头为-1（表示所有节点初始时无邻接边）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=mm;i++)<br>    {<br>        cin&gt;&gt;m[i].u&gt;&gt;m[i].v&gt;&gt;m[i].w;<span class="hljs-comment">// 读入第i条边的起点u、终点v、权值w</span><br>        m[i].lk=h[m[i].u];<span class="hljs-comment">// 将当前边的下一条边指向节点u原邻接表的表头</span><br>        h[m[i].u]=i; <span class="hljs-comment">// 更新节点u的邻接表表头为当前边的索引（头插法插入新边）</span><br>    }<br>    <span class="hljs-comment">// SPFA算法初始化：队列存储待处理的节点</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    b[s]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// SPFA主循环：处理队列中的节点，松弛邻接边</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    {<br>        <span class="hljs-type">int</span> k=h[q.<span class="hljs-built_in">front</span>()];<br>        b[q.<span class="hljs-built_in">front</span>()]=<span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">pop</span>();          <span class="hljs-comment">// 弹出队首节点</span><br>        <span class="hljs-comment">// 遍历节点u的所有邻接边（通过邻接表的链式结构）</span><br>        <span class="hljs-keyword">while</span>(k!=<span class="hljs-number">-1</span>)<br>        {<br>            <span class="hljs-comment">// 松弛操作：若通过u→v的路径能缩短源点到v的距离，则更新d[v]</span><br>            <span class="hljs-keyword">if</span>(d[m[k].v]&gt;d[m[k].u]+m[k].w)<br>            {<br>                d[m[k].v]=d[m[k].u]+m[k].w;<br>                <span class="hljs-comment">// 若v不在队列中，则将其入队（避免重复处理）</span><br>                <span class="hljs-keyword">if</span>(!b[m[k].v])<br>                {<br>                    cnt[m[k].v]++;<br>                    q.<span class="hljs-built_in">push</span>(m[k].v);<br>                    b[m[k].v]=<span class="hljs-number">1</span>;<br>                     <span class="hljs-comment">// 若v的入队次数超过节点数n，说明存在负权环（最短路径不可</span><br>                    <span class="hljs-keyword">if</span>(cnt[m[k].v]&gt;n)<br>                    {<br>                        cout&lt;&lt;<span class="hljs-string">"负环"</span>;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                    }<br>                }<br>            }<br>            <span class="hljs-comment">// 遍历下一条边（通过lk指针访问邻接表的下一个节点）</span><br>            k=m[k].lk;<br>        }<br>    }<br>    <span class="hljs-comment">// 输出源点到所有节点的最短距离（若仍为0x3f则表示不可达）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        cout&lt;&lt;d[i]&lt;&lt;<span class="hljs-string">' '</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="10bellman-ford">10.Bellman-Ford</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// 定义无穷大（比一般整数大，避免溢出）</span><br><br><span class="hljs-type">int</span> n, mm, s; <span class="hljs-comment">// n:节点数，mm:边数，s:起点</span><br><span class="hljs-type">int</span> d[MAXN]; <span class="hljs-comment">// d[i]:起点s到i的最短距离</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> <br>{<br>    <span class="hljs-type">int</span> u, v, w; <span class="hljs-comment">// 边的起点u、终点v、权值w（lk未使用，可保留）</span><br>    <span class="hljs-type">int</span> lk; <span class="hljs-comment">// 邻接表指针（Bellman-Ford无需使用，可忽略）</span><br>} m[MAXN]; <span class="hljs-comment">// 存储所有边</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin &gt;&gt; n &gt;&gt; mm &gt;&gt; s;<br>    <br>    <span class="hljs-comment">// 初始化距离数组：所有节点距离为INF，起点距离为0</span><br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(d));<br>    d[s] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 输入所有边（保留邻接表结构，但Bellman-Ford无需使用）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=mm; i++)<br>    {<br>        cin &gt;&gt; m[i].u &gt;&gt; m[i].v &gt;&gt; m[i].w;<br>        m[i].lk = <span class="hljs-number">0</span>; <span class="hljs-comment">// 可省略，不影响结果</span><br>    }<br>    <br>    <span class="hljs-comment">// ---------------------- Bellman-Ford核心逻辑 ----------------------</span><br>    <span class="hljs-comment">// 1. 迭代n-1次，松弛所有边（最短路径最多含n-1条边）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n<span class="hljs-number">-1</span>; i++) <br>    {<br><br>        <span class="hljs-type">bool</span> updated = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 优化：若本次迭代无松弛，提前终止（可选）</span><br>        <span class="hljs-comment">// 遍历所有边（直接遍历m数组，无需邻接表）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=mm; j++) <br>        {<br>            <span class="hljs-type">int</span> u = m[j].u;<br>            <span class="hljs-type">int</span> v = m[j].v;<br>            <span class="hljs-type">int</span> w = m[j].w;<br>            <span class="hljs-comment">// 松弛条件：u可达（d[u]≠INF），且v的距离可通过u缩短</span><br>            <span class="hljs-keyword">if</span> (d[u] != INF &amp;&amp; d[v] &gt; d[u] + w) <br>            {<br>                d[v] = d[u] + w;<br>                updated = <span class="hljs-literal">true</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (!updated) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 无松弛，提前终止（可选，提升效率）</span><br>    }<br>    <br>    <span class="hljs-comment">// 2. 检测负权环：若n-1次后仍能松弛，说明存在负环</span><br>    <span class="hljs-type">bool</span> has_negative_cycle = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=mm; j++) <br>    {<br>        <span class="hljs-type">int</span> u = m[j].u;<br>        <span class="hljs-type">int</span> v = m[j].v;<br>        <span class="hljs-type">int</span> w = m[j].w;<br>        <span class="hljs-keyword">if</span> (d[u] != INF &amp;&amp; d[v] &gt; d[u] + w) <br>        {<br>            has_negative_cycle = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (has_negative_cycle) <br>    {<br>        cout &lt;&lt; <span class="hljs-string">"负环"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-comment">// ---------------------- Bellman-Ford核心逻辑结束 ----------------------</span><br>    <br>    <span class="hljs-comment">// 输出最短距离（未到达的节点仍为INF）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <br>        cout &lt;&lt; (d[i] == INF ? <span class="hljs-string">"INF"</span> : <span class="hljs-built_in">to_string</span>(d[i])) &lt;&lt; <span class="hljs-string">' '</span>;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="11floyd">11.Floyd</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1e3</span><span class="hljs-number">+10</span>; <span class="hljs-comment">// Floyd算法时间复杂度O(n³)，n建议≤1e3（否则超时）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// 表示不可达的距离（需大于所有边权之和）</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dist[MAXN][MAXN]; <span class="hljs-comment">// dist[i][j]：i到j的最短距离</span><br><span class="hljs-type">int</span> n, mm; <span class="hljs-comment">// n：节点数；mm：边数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 加速输入输出</span><br>    cin&gt;&gt;n&gt;&gt;mm;<br><br>    <span class="hljs-comment">// 1. 初始化距离矩阵</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist)); <span class="hljs-comment">// 初始化为INF</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        dist[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 自身到自身的距离为0</span><br><br>    <span class="hljs-comment">// 2. 输入边（默认处理有向边，无向边需添加反向边）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=mm;i++)<br>    {<br>        <span class="hljs-type">int</span> u, v, x;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;x;<br>        dist[u][v] = <span class="hljs-built_in">min</span>(dist[u][v], x); <span class="hljs-comment">// 处理重边（保留最小权值）</span><br>        <span class="hljs-comment">// 若为无向边，需添加：dist[v][u] = min(dist[v][u], x);</span><br>    }<br><br>    <span class="hljs-comment">// 3. Floyd-Warshall核心算法（通过中间点k松弛所有路径）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++) <span class="hljs-comment">// 中间点k（必须放在最外层）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">// 起点i</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) <span class="hljs-comment">// 终点j</span><br>                <span class="hljs-keyword">if</span>(dist[i][k] != INF &amp;&amp; dist[k][j] != INF) <span class="hljs-comment">// 避免溢出（INF+INF会超界）</span><br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br><br>    <span class="hljs-comment">// 4. 输出所有节点对的最短距离（i到j的最短距离）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        {<br>            <span class="hljs-keyword">if</span>(dist[i][j] == INF)<br>                cout&lt;&lt;<span class="hljs-string">"INF "</span>; <span class="hljs-comment">// 可选：用特定符号表示不可达（如-1）</span><br>            <span class="hljs-keyword">else</span><br>                cout&lt;&lt;dist[i][j]&lt;&lt;<span class="hljs-string">' '</span>;<br>        }<br>        cout&lt;&lt;endl; <span class="hljs-comment">// 每行结束换行</span><br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="12%E7%BD%91%E7%BB%9C%E6%B5%81%E6%9C%80%E5%A4%A7%E6%B5%81dicnic">12.网络流最大流（Dicnic）</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM=<span class="hljs-number">10000</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">210</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>ll n,m,s,t,u,v,w,cnt=<span class="hljs-number">-1</span>,head[MAXN],cur[MAXN],ans,deep[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    ll next,v,w;<br>}edge[MAXM];<br><span class="hljs-comment">//加边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll u,ll v,ll w,<span class="hljs-type">bool</span> flag)</span></span><br><span class="hljs-function"></span>{<br>    edge[++cnt].next=head[u];<br>    edge[cnt].v=v;<br>    <span class="hljs-keyword">if</span>(flag) edge[cnt].w=w;<br>    head[u]=cnt;<br>}<br><span class="hljs-comment">// DFS：寻找增广路</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll u,ll t,ll lim)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span>(!lim || u==t) <span class="hljs-keyword">return</span> lim;<span class="hljs-comment">// 如果没有剩余流量或到达汇点，返回当前流量</span><br>    ll flow=<span class="hljs-number">0</span>,f;<span class="hljs-comment">// flow记录当前点的总流量，f记录单次DFS的流量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">-1</span>;i=edge[i].next)<span class="hljs-comment">// 当前弧优化，从当前边开始遍历</span><br>    {<br>        cur[u]=i;<br>        <span class="hljs-keyword">if</span>(deep[edge[i].v]==deep[u]<span class="hljs-number">+1</span> &amp;&amp; (f=<span class="hljs-built_in">dfs</span>(edge[i].v,t,<span class="hljs-built_in">min</span>(lim,edge[i].w))))  <span class="hljs-comment">// 如果下一层是u的下一层且可以增广</span><br>        {<br>            flow+=f;<span class="hljs-comment">// 累加流量</span><br>            lim-=f;  <span class="hljs-comment">// 减少剩余流量</span><br>            edge[i].w-=f;<span class="hljs-comment">// 更新正向边容量</span><br>            edge[i^<span class="hljs-number">1</span>].w+=f;<span class="hljs-comment">// 更新反向边容量（异或1得到反向边索引）</span><br>            <span class="hljs-keyword">if</span>(!lim) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 如果剩余流量为0，提前退出</span><br>        }<br>    }<br>    <span class="hljs-keyword">return</span> flow; <span class="hljs-comment">// 返回当前点的总流量</span><br>}<br><br><span class="hljs-comment">// BFS：构建分层图</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(ll s,ll t)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(deep,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(deep));<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cur[i]=head[i]; <span class="hljs-comment">// 重置当前弧</span><br>    deep[s]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(s);<span class="hljs-comment">// 源点入队</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    {<br>        ll u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i!=<span class="hljs-number">-1</span>;i=edge[i].next)<span class="hljs-comment">// 遍历u的所有邻边</span><br>        {<br>            <span class="hljs-keyword">if</span>(deep[edge[i].v]&gt;inf &amp;&amp; edge[i].w)<span class="hljs-comment">// 如果邻点未被访问且边有容量</span><br>            {<br>                deep[edge[i].v]=deep[u]<span class="hljs-number">+1</span>;<span class="hljs-comment">// 设置邻点深度</span><br>                q.<span class="hljs-built_in">push</span>(edge[i].v);   <span class="hljs-comment">// 邻点入队</span><br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span>(deep[t]&lt;inf) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果汇点可达，返回true</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dicnic</span><span class="hljs-params">(ll s,ll t)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>(s,t)) ans+=<span class="hljs-built_in">dfs</span>(s,t,inf);<span class="hljs-comment">// 只要汇点可达，累加增广路的流量</span><br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    {<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>        <span class="hljs-built_in">add</span>(u,v,w,<span class="hljs-number">1</span>);<span class="hljs-comment">// 添加正向边</span><br>        <span class="hljs-built_in">add</span>(v,u,w,<span class="hljs-number">0</span>);<span class="hljs-comment">// 添加反向边（初始容量为0）</span><br>    }<br><span class="hljs-comment">//	for(int i=1;i&lt;=cnt;i++) </span><br><span class="hljs-comment">//		cout&lt;&lt;edge[i].v&lt;&lt;' '&lt;&lt;edge[i].w&lt;&lt;' '&lt;&lt;edge[i].next&lt;&lt;endl;</span><br>    <br>    <span class="hljs-built_in">dicnic</span>(s,t);<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="13%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81spfa">13.最小费用最大流（SPFA）</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">5e3</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>ll n,m,s,t,u,v,f,d,maxflow,mincost,head[MAXN],vis[MAXN],dis[MAXN],pre[MAXN],cnt,flow[MAXN],last[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    ll next,v,flow,dis;<br>}edge[MAXM];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll u,ll v,ll f,ll d)</span></span><br><span class="hljs-function"></span>{<br>    edge[++cnt].next=head[u];<br>    edge[cnt].v=v;<br>    edge[cnt].flow=f;<br>    edge[cnt].dis=d;<br>    head[u]=cnt;<br>}<br><span class="hljs-comment">// SPFA算法寻找最小费用增广路径</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(ll s,ll t)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-built_in">memset</span>(flow,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(flow));<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>    queue&lt;ll&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 源点入队</span><br>    vis[s]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 标记已访问</span><br>    dis[s]=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 源点距离为0</span><br>    pre[t]=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 汇点前驱初始化为-1（用于判断是否找到路径）</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    {<br>        ll now=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[now]=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 出队取消标记</span><br>        <span class="hljs-comment">// 遍历当前节点的所有出边</span><br>        <span class="hljs-keyword">for</span>(ll i=head[now];i!=<span class="hljs-number">-1</span>;i=edge[i].next)<br>        {<br>            <span class="hljs-comment">// 若边有剩余容量且可松弛</span><br>            <span class="hljs-keyword">if</span>(edge[i].flow&gt;<span class="hljs-number">0</span> &amp;&amp; dis[edge[i].v]&gt;dis[now]+edge[i].dis)<br>            {<br>                dis[edge[i].v]=dis[now]+edge[i].dis;<span class="hljs-comment">// 更新距离</span><br>                pre[edge[i].v]=now;  <span class="hljs-comment">// 记录前驱节点</span><br>                last[edge[i].v]=i;      <span class="hljs-comment">// 记录边的编号</span><br>                flow[edge[i].v]=<span class="hljs-built_in">min</span>(flow[now],edge[i].flow);<span class="hljs-comment">// 更新可增广流量</span><br>                <span class="hljs-comment">// 若目标节点未入队，则入队</span><br>                <span class="hljs-keyword">if</span>(!vis[edge[i].v])<br>                {<br>                    vis[edge[i].v]=<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(edge[i].v);<br>                }<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> pre[t]!=<span class="hljs-number">-1</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MCMF</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">spfa</span>(s,t))  <span class="hljs-comment">// 当存在增广路径时</span><br>    {<br>        ll now=t;<br>        maxflow+=flow[t];  <span class="hljs-comment">// 更新总流量</span><br>        mincost+=flow[t]*dis[t]; <span class="hljs-comment">// 更新总费用（流量*路径单位费用和）</span><br>        <span class="hljs-comment">// 回溯更新路径上的边流量</span><br>        <span class="hljs-keyword">while</span>(now!=s)<br>        {<br>            edge[last[now]].flow-=flow[t];<br>            <span class="hljs-comment">// 正向边减去增广流量</span><br>            edge[last[now]^<span class="hljs-number">1</span>].flow+=flow[t];<br>            <span class="hljs-comment">// 反向边增加增广流量（用于回退）</span><br>            now=pre[now];<span class="hljs-comment">// 移动到前驱节点</span><br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    {<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;f&gt;&gt;d;<br>        <span class="hljs-built_in">add</span>(u,v,f,d);<br>        <span class="hljs-built_in">add</span>(v,u,<span class="hljs-number">0</span>,-d);<br>    }<br>    <span class="hljs-built_in">MCMF</span>();<br>    cout&lt;&lt;maxflow&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;mincost&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="14%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">14.单调队列</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> n,k,a[N];<br><span class="hljs-type">int</span> ans1[N],ans2[N];<br><br><span class="hljs-type">int</span> q[N],head,tail;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Calc</span><span class="hljs-params">(<span class="hljs-type">int</span> res[])</span> <span class="hljs-comment">//指针传参，答案计入 res 数组</span></span><br><span class="hljs-function"></span>{<br>    head=<span class="hljs-number">1</span>,tail=<span class="hljs-number">0</span>; <span class="hljs-comment">//清空队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//枚举窗口右端</span><br>    {<br>      <span class="hljs-keyword">while</span>(head&lt;=tail &amp;&amp; i-q[head]<span class="hljs-number">+1</span>&gt;k) q[head++]=<span class="hljs-number">0</span>; <span class="hljs-comment">//弹出已经离开窗口的元素</span><br>      <span class="hljs-keyword">while</span>(head&lt;=tail &amp;&amp; a[q[tail]]&gt;a[i]) q[tail--]=<span class="hljs-number">0</span>; <span class="hljs-comment">//从队尾踢掉之前所有比当前元素大的数</span><br>      q[++tail]=i; <span class="hljs-comment">//当前元素自己加入队尾</span><br>      <span class="hljs-keyword">if</span>(i&gt;=k) res[i-k<span class="hljs-number">+1</span>]=q[head]; <span class="hljs-comment">//完成以上操作后，队头即为最小值</span><br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>    <br>    <span class="hljs-built_in">Calc</span>(ans1); <span class="hljs-comment">//计算滑动窗口最小值位置，答案计入 ans1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n-k<span class="hljs-number">+1</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[ans1[i]]);<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        a[i]=-a[i]; <span class="hljs-comment">//所有元素取相反数</span><br>    <span class="hljs-built_in">Calc</span>(ans2); <span class="hljs-comment">//计算此时的滑动窗口最小值位置，答案计入 ans2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n-k<span class="hljs-number">+1</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,-a[ans2[i]]); <span class="hljs-comment">//再取一遍相反数即为最大值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="15%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">15.树的直径</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">4</span>*<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,a[MAXN],cnt,head[MAXN];<br><span class="hljs-type">bool</span> b[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>{<br>    <span class="hljs-type">int</span> v,lk;<br>}edge[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>{<br>    edge[++cnt].v=v;<br>    edge[cnt].lk=head[u];<br>    head[u]=cnt;<br>}<br><span class="hljs-comment">// 第一次BFS：从指定起点找到最远节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>{<br>    b[u]=<span class="hljs-number">1</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    {<br>        <span class="hljs-type">int</span> v=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前节点</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 遍历当前节点的所有邻居</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[v];i!=<span class="hljs-number">0</span>;i=edge[i].lk)<br>        {<br>            <span class="hljs-type">int</span> w=edge[i].v;<span class="hljs-comment">// 邻居节点</span><br>            <span class="hljs-keyword">if</span>(b[w]==<span class="hljs-number">0</span>) <span class="hljs-comment">// 如果邻居未访问过</span><br>            {<br>                b[w]=<span class="hljs-number">1</span>;<br>                a[w]=a[v]<span class="hljs-number">+1</span>;<span class="hljs-comment">// 更新距离（从起点u到w的距离）</span><br>                q.<span class="hljs-built_in">push</span>(w);<br>            }<br>        }<br>    }<br>    <span class="hljs-type">int</span> maxx=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxid=<span class="hljs-number">0</span>;<br><br>     <span class="hljs-comment">// 查找距离最大的节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    {<br>        <span class="hljs-keyword">if</span>(a[i]&gt;maxx)<br>        {<br>            maxx=a[i];<br>            maxid=i; <span class="hljs-comment">// 记录距离最大的节点ID</span><br>        }<br>    }<br>    <span class="hljs-keyword">return</span> maxid;<span class="hljs-comment">// 返回距离最远的节点</span><br>}<br><br><span class="hljs-comment">// 第二次BFS：从第一次找到的最远节点出发，计算树的直径</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<span class="hljs-comment">// 重置距离数组</span><br>    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<span class="hljs-comment">// 重置访问标记</span><br>    b[u]=<span class="hljs-number">1</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    {<br>        <span class="hljs-type">int</span> v=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[v];i!=<span class="hljs-number">0</span>;i=edge[i].lk)<br>        {<br>            <span class="hljs-type">int</span> w=edge[i].v;<br>            <span class="hljs-keyword">if</span>(b[w]==<span class="hljs-number">0</span>)<br>            {<br>                b[w]=<span class="hljs-number">1</span>;<br>                a[w]=a[v]<span class="hljs-number">+1</span>;<br>                q.<span class="hljs-built_in">push</span>(w);<br>            }<br>        }<br>    }<br>    <span class="hljs-type">int</span> maxx=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxid=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 直接返回最大距离（树的直径）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    {<br>        <span class="hljs-keyword">if</span>(a[i]&gt;maxx)<br>        {<br>            maxx=a[i];<br>            maxid=i;<br>        }<br>    }<br>     <span class="hljs-comment">// 返回树的直径长度</span><br>    <span class="hljs-keyword">return</span> maxx;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>    {<br>        <span class="hljs-type">int</span> u,v;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        <span class="hljs-built_in">add</span>(u,v);<br>        <span class="hljs-built_in">add</span>(v,u);<br>    }<br>    <span class="hljs-type">int</span> v=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> u=<span class="hljs-built_in">bfs1</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans=<span class="hljs-built_in">bfs2</span>(u);<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="16stl">16.STL</span></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span>、vector容器（向量）<br><br><span class="hljs-number">1.</span>简介<br>    vector是将元素置于一个动态数组中加以管理的容器<br>    vector可以随机存取元素（支持索引值直接存取，用[]操作符或<span class="hljs-built_in">at</span>()的方法）<br>    vector尾部添加或移除元素非常快速，但是中部或头部插入或移除元素比较费时<br><br><span class="hljs-number">2.</span>vector对象的默认构造<br>    vector采用模板类实现，vector对象的默认构造形式<br><br>    vector&lt;T&gt; vecT;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; vecInt;		<span class="hljs-comment">//一个存放int类型元素的vector容器</span><br>    vector&lt;<span class="hljs-type">float</span>&gt;vecFloat;		<span class="hljs-comment">//一个存放float类型元素的vector容器</span><br>    vector&lt;string&gt;vecString;		<span class="hljs-comment">//一个存放string类型元素的vector容器</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CA</span>{};<br>    vector&lt;CA*&gt; vecpCA;		<span class="hljs-comment">//用于存放类CA的指针的vector容器</span><br>    vector&lt;CA&gt; vecCA;		<span class="hljs-comment">//用于存放类CA的vector容器</span><br>                            <span class="hljs-comment">//所以此时CA必须提供CA的拷贝构造函数，以保证CA对象之间拷贝正常</span><br><br>    vec.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//返回vector容器中元素的个数</span><br>    vec.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判断vector容器是否为空</span><br>    vec.<span class="hljs-built_in">resize</span>(num, elem); <span class="hljs-comment">//重新指定容器的长度为num。若容器变长，则以elem值重新填充新位置；若容器变短，则末尾超出容器长度的元素被删除。</span><br>    vec[idx]; <span class="hljs-comment">//返回下标(索引)idx所指的数据，越界时，运行直接报错</span><br>    vec.<span class="hljs-built_in">at</span>(idx); <span class="hljs-comment">//返回下标(索引)idx所指的数据，如果idx越界，抛出异常终止的原因（程序仍然会异常终止）</span><br>    vec.<span class="hljs-built_in">push_back</span>(num); <span class="hljs-comment">//在vec的末尾插入一个num元素</span><br>    vec.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//删除vec的末尾的一个元素</span><br>    vec.<span class="hljs-built_in">insert</span>(pos, elem); <span class="hljs-comment">//在pos位置插入一个elem元素，返回新数据的位置</span><br>    vec.<span class="hljs-built_in">insert</span>(pos, n, elem); <span class="hljs-comment">//在pos位置插入n个elem元素，无返回值</span><br>    vec.<span class="hljs-built_in">insert</span>(pos, beg, end); <span class="hljs-comment">//在pos位置插入[beg, end)区间的数据，无返回值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter; <span class="hljs-comment">//迭代器变量名为iter</span><br>    it = v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">//输出此时的it指向的元素</span><br>    cout &lt;&lt; *it &lt;&lt; endl;<br>    <span class="hljs-comment">//通过循环使用迭代器遍历v1容器中的所有元素</span><br>    <span class="hljs-keyword">for</span> (it = v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(); it != v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(); it++)<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;<br><br><br><span class="hljs-number">2</span>、deque容器（双端队列）<br><br>    deque是<span class="hljs-string">"double-ended queue"</span>的缩写，和vector一样都是STL的容器<br>    deque是双端数组而vector是单端的<br>    deque在接口上和vector非常相似，在许多操作的地方可以直接替换<br>    deque可以随机存取元素（支持索引值直接存取，用[ ]操作符或<span class="hljs-built_in">at</span>( )方法）<br>    deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时<br>    需要使用头文件<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br>    包含victor的所有函数<br>    deque.<span class="hljs-built_in">push_front</span>(elem);		<span class="hljs-comment">//在容器头部插入一个数据</span><br>    deque.<span class="hljs-built_in">pop_front</span>();		<span class="hljs-comment">//删除容器的第一个数据</span><br><br><br><span class="hljs-number">3</span>、stack容器（栈）<br><span class="hljs-number">1.</span>stack对象的默认构造<br>    stack采用模板类实现，stack对象的默认构造形式为：stack&lt;T&gt; s;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s; <span class="hljs-comment">//一个存放int的stack容器</span><br>    stack&lt;<span class="hljs-type">float</span>&gt; s; <span class="hljs-comment">//一个存放float的stack容器</span><br>    stack&lt;string&gt; s; <span class="hljs-comment">//一个存放string的stack容器</span><br><span class="hljs-number">2.</span>stack常用的成员函数<br>    stack.<span class="hljs-built_in">push</span>(elem) <span class="hljs-comment">//在栈顶增加元素（入栈）</span><br>    stack.<span class="hljs-built_in">pop</span>( ) <span class="hljs-comment">//移除栈顶元素（出栈）</span><br>    stack.<span class="hljs-built_in">empty</span>( ) <span class="hljs-comment">//堆栈为空则返回真</span><br>    stack.<span class="hljs-built_in">size</span>( ) <span class="hljs-comment">//返回栈中元素数目</span><br>    stack.<span class="hljs-built_in">top</span>( ) <span class="hljs-comment">//返回栈顶元素</span><br><br><br><span class="hljs-number">4</span>、queue容器（队列）<br>    queue是队列容器，是一种“先进先出”的容器<br>    需要使用头文件<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-number">1.</span>queue对象的默认构造<br>    queue采用模板类，queue对象的默认构造形式：queue&lt;T&gt; q;<br>    queue&lt;<span class="hljs-type">int</span>&gt; queInt;		<span class="hljs-comment">//一个存放int的queue容器</span><br>    queue&lt;<span class="hljs-type">float</span>&gt; queFloat;		<span class="hljs-comment">//一个存放float的queue容器</span><br>    queue&lt;string&gt; queString;	<span class="hljs-comment">//一个存放string的queue容器</span><br><span class="hljs-number">2.</span>queue容器的常用成员函数<br>    queue.<span class="hljs-built_in">push</span>(elem) <span class="hljs-comment">//在队列尾部增加元素（入队）</span><br>    queue.<span class="hljs-built_in">pop</span>( ) <span class="hljs-comment">//删除队首元素（出队）</span><br>    queue.<span class="hljs-built_in">empty</span>( ) <span class="hljs-comment">//队列为空则返回真</span><br>    queue.<span class="hljs-built_in">size</span>( ) <span class="hljs-comment">//返回队列中元素数目</span><br>    queue.<span class="hljs-built_in">front</span>( ) <span class="hljs-comment">//返回队首元素（可以作为左值被修改）</span><br>    queue.<span class="hljs-built_in">back</span>( ) <span class="hljs-comment">//返回队尾元素</span><br><br><br><span class="hljs-number">5</span>、list容器（双向链表）<br><span class="hljs-number">1.</span>基本概念<br>    list是一个双向链表容器，可高效地进行插入和删除元素<br>    list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符<br>    it++ <span class="hljs-comment">//迭代器自增、自减是正确的</span><br>    it<span class="hljs-number">+5</span> <span class="hljs-comment">//迭代器一次移动多个是错误的</span><br><span class="hljs-number">2.l</span>ist容器的头部和尾部操作<br>    list采用模板类实现，对象的默认构造形式：list&lt;T&gt; lst，例如：<br>    list&lt;<span class="hljs-type">int</span>&gt; lstInt;	<span class="hljs-comment">//定义一个存放int的list容器</span><br>    list&lt;<span class="hljs-type">float</span>&gt; lstFloat;	<span class="hljs-comment">//定义一个存放float的list容器</span><br>    list&lt;string&gt; lstString;	<span class="hljs-comment">//定义一个存放string的list容器</span><br><br>    list.<span class="hljs-built_in">push_back</span>(elem); <span class="hljs-comment">//在容器尾部加入一个元素</span><br>    list.<span class="hljs-built_in">pop_back</span>( ); <span class="hljs-comment">//删除容器中最后一个元素</span><br>    list.<span class="hljs-built_in">push_front</span>(elem); <span class="hljs-comment">//在容器头部加入一个元素</span><br>    list.<span class="hljs-built_in">pop_front</span>( ); <span class="hljs-comment">//删除容器中第一个元素</span><br>    list.<span class="hljs-built_in">begin</span>();	<span class="hljs-comment">//返回容器中第一个元素的迭代器</span><br>    list.<span class="hljs-built_in">end</span>();		<span class="hljs-comment">//返回容器中最后一个元素之后的迭代器</span><br>    list.<span class="hljs-built_in">rbegin</span>();	<span class="hljs-comment">//返回容器中倒数第一个元素的迭代器</span><br>    list.<span class="hljs-built_in">rend</span>();	<span class="hljs-comment">//返回容器中倒数最后一个元素的后面的迭代器</span><br>    <span class="hljs-built_in">list</span>(n,elem); <span class="hljs-comment">//构造函数将n个elem拷贝给本身</span><br>    <span class="hljs-built_in">list</span>(beg,end); <span class="hljs-comment">//构造函数将[beg,end)区间中的元素拷贝给本身</span><br>    <span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list &amp;lst); <span class="hljs-comment">//拷贝构造函数</span><br>    list.<span class="hljs-built_in">assign</span>(beg,end); <span class="hljs-comment">//将[beg,end)区间中的数据拷贝赋值给本身</span><br>    list.<span class="hljs-built_in">assign</span>(n,elem); <span class="hljs-comment">//将n个elem拷贝赋值给本身</span><br>    list&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> list &amp;lst); <span class="hljs-comment">//重载等号操作符</span><br>    list.<span class="hljs-built_in">swap</span>(lst); <span class="hljs-comment">//交换两个头指针的位置，类似于交换元素</span><br>(<span class="hljs-number">1</span>)专用成员函数<br>    <span class="hljs-built_in">merge</span>(b)：将链表b与调用链表合并，在合并之前，两个链表必须已经排序，合并后经过排序的链表被保存在调用链表中，b为空。<br>    <span class="hljs-built_in">remove</span>(val)：从链表中删除val的所有节点。<br>    <span class="hljs-built_in">splice</span>(pos,b)：将链表b的内容插入pos的前面，b为空。<br>    <span class="hljs-built_in">reverse</span>( )：将链表翻转。<br>    <span class="hljs-built_in">sort</span>( )：将链表排序。<br>    <span class="hljs-built_in">unique</span>( )：将连续的相同元素压缩为单个元素。不连续的相同元素无法压缩，因此一般先排序后去重。<br>(<span class="hljs-number">2</span>)其他成员函数<br>    <span class="hljs-built_in">push_front</span>(x)/<span class="hljs-built_in">push_back</span>(x)：x从链表头或尾入。<br>    <span class="hljs-built_in">pop_front</span>( )/<span class="hljs-built_in">pop_back</span>( )：从链表头或尾出。<br>    <span class="hljs-built_in">front</span>( )/<span class="hljs-built_in">back</span>( )：返回链表头或尾元素。<br>    <span class="hljs-built_in">insert</span>(p, t)：在p之前插入t。<br>    <span class="hljs-built_in">erase</span>(p)：删除p。<br>    <span class="hljs-built_in">clear</span>( )：清空链表。<br><br><br><span class="hljs-number">6</span>、set/multiset容器（集合）<br><span class="hljs-number">1.</span>set/multiset容器的基本概念<br>    set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置<br>    set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快<br>    set不可以直接存取元素（不可以使用at.(pos)与[ ]操作符）<br>    multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次<br>    不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素<br>    set或multiset的迭代器为双向访问，不支持随机访问。执行一次“++”和“- -”操作的时间复杂度均为<span class="hljs-built_in">O</span>(logn)。默认的元素顺序为升序，也可以通过第<span class="hljs-number">2</span>个模版的参数设置为降序<br><span class="hljs-number">2.</span>set容器的插入和迭代器<br>    set.<span class="hljs-built_in">insert</span>(elem); <span class="hljs-comment">//在容器中插入元素</span><br>    set.<span class="hljs-built_in">begin</span>( ); <span class="hljs-comment">//返回容器中第一个数据的迭代器</span><br>    set.<span class="hljs-built_in">end</span>( ); <span class="hljs-comment">//返回容器中最后一个数据之后的迭代器</span><br>    set.<span class="hljs-built_in">rbegin</span>( ); <span class="hljs-comment">//返回容器中倒数第一个元素的迭代器</span><br>    set.<span class="hljs-built_in">rend</span>( ); <span class="hljs-comment">//返回容器中倒数最后一个元素的后面的迭代器</span><br><span class="hljs-number">3.</span>set的成员函数<br>    size/empty/clear：元素个数、判空、清空<br>    begin/end：开始位置和结束位置<br>    <span class="hljs-built_in">insert</span>(x)：将元素x插入集合<br>    <span class="hljs-built_in">erase</span>(x)：删除所有等于x的元素<br>    <span class="hljs-built_in">erase</span>(it)：删除it迭代器指向的元素<br>    <span class="hljs-built_in">find</span>(x)：查找元素x在集合中的位置，若不存在，则返回<span class="hljs-function">end</span><br><span class="hljs-function">    <span class="hljs-title">count</span><span class="hljs-params">(x)</span>：统计等于x的元素个数</span><br><span class="hljs-function">    <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">(x)</span>：返回大于或等于x的最小元素位置、大于x的最小元素位置</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">7、map容器（映射）</span><br><span class="hljs-function">1.map的基本概念</span><br><span class="hljs-function">​ 	map的键和值可以是不同的类型，键是唯一的，每个键都对应一个值。map可被当作哈希表使用，它建立了从键（关键字）到值的映射。map是键和值的一一映射</span><br><span class="hljs-function">2.map的成员函数</span><br><span class="hljs-function">    size/empty/clear：元素个数、判空、清空</span><br><span class="hljs-function">    begin/end：开始位置和结束位置</span><br><span class="hljs-function">    <span class="hljs-title">insert</span><span class="hljs-params">(x)</span>：将元素x插入集合（x为二元组）</span><br><span class="hljs-function">    <span class="hljs-title">erase</span><span class="hljs-params">(x)</span>：删除所有等于x的元素（x为二元组）</span><br><span class="hljs-function">    <span class="hljs-title">erase</span><span class="hljs-params">(it)</span>：删除it指向的元素（it为指向二元组的迭代器）</span><br><span class="hljs-function">    <span class="hljs-title">find</span><span class="hljs-params">(k)</span>：查找键位k的二元组的位置，若不存在，则返回尾指针</span><br></code></pre></td></tr></tbody></table></figure></body></html>
	</article>

	 
    <div class="kira-post-copyright">
        <strong>Author：</strong>青筱听风<br>
        <strong>Link：</strong><a href="https://lorcas.top/2025/10/13/ACM-%E6%A8%A1%E6%9D%BF/" title="https:&#x2F;&#x2F;lorcas.top&#x2F;2025&#x2F;10&#x2F;13&#x2F;ACM-模板&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;lorcas.top&#x2F;2025&#x2F;10&#x2F;13&#x2F;ACM-模板&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			          
			<!-- 先找到与当前文字相同的目录 -->
			   
			<!-- 在找到当前文章所在的 index -->
			          
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/%E6%A8%A1%E6%9D%BF/">模板</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/ACM/" rel="tag">ACM</a>
		
	</div>
	
	<div class="kira-post-footer">
		
	<link rel="stylesheet" href="https://unpkg.com/gitalk@latest/dist/gitalk.css" />
	<div id="gitalk"></div>
	<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
	<script type="text/javascript">
		const gitalk = new Gitalk({
			clientID: 'Ov23liek4BIB6FAFBJ3k',
			clientSecret: '122b3f2f91e99c4bc1235847e0e15c806f7e9748',
			id: 'ACM 模板',
			repo: 'gitalk',
			owner: 'Lorcas-Zephyr',
			admin: 'Lorcas-Zephyr',
			title: 'gitalk',
		});
		gitalk.render('gitalk');
	</script>


		
	</div>
	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
		<span class="post-meta-divider">|</span>
		<span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>


		</div>
	</body>
</html>